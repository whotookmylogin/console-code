"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/testing/index.ts
var testing_exports = {};
__export(testing_exports, {
  WxtVitest: () => WxtVitest,
  fakeBrowser: () => import_fake_browser.fakeBrowser
});
module.exports = __toCommonJS(testing_exports);

// src/testing/fake-browser.ts
var import_fake_browser = require("@webext-core/fake-browser");

// src/core/utils/entrypoints.ts
var import_node_path2 = __toESM(require("path"), 1);

// src/core/utils/paths.ts
var import_node_path = __toESM(require("path"), 1);
var import_normalize_path = __toESM(require("normalize-path"), 1);
function normalizePath(path8) {
  return (0, import_normalize_path.default)(path8);
}
var CSS_EXTENSIONS = ["css", "scss", "sass", "less", "styl", "stylus"];
var CSS_EXTENSIONS_PATTERN = `+(${CSS_EXTENSIONS.join("|")})`;

// src/core/builders/vite/plugins/devHtmlPrerender.ts
var import_linkedom = require("linkedom");
var import_node_path3 = require("path");

// src/core/utils/network.ts
var import_node_dns = __toESM(require("dns"), 1);

// src/core/utils/time.ts
function withTimeout(promise, duration) {
  return new Promise((res, rej) => {
    const timeout = setTimeout(() => {
      rej(`Promise timed out after ${duration}ms`);
    }, duration);
    promise.then(res).catch(rej).finally(() => clearTimeout(timeout));
  });
}

// src/core/utils/network.ts
function isOffline() {
  const isOffline2 = new Promise((res) => {
    import_node_dns.default.resolve("google.com", (err) => {
      if (err == null) {
        res(false);
      } else {
        res(true);
      }
    });
  });
  return withTimeout(isOffline2, 1e3).catch(() => true);
}
async function isOnline() {
  const offline = await isOffline();
  return !offline;
}
async function fetchCached(url, config) {
  let content = "";
  if (await isOnline()) {
    const res = await fetch(url);
    if (res.status < 300) {
      content = await res.text();
      await config.fsCache.set(url, content);
    } else {
      config.logger.debug(
        `Failed to download "${url}", falling back to cache...`
      );
    }
  }
  if (!content)
    content = await config.fsCache.get(url) ?? "";
  if (!content)
    throw Error(
      `Offline and "${url}" has not been cached. Try again when online.`
    );
  return content;
}

// src/core/builders/vite/plugins/download.ts
function download(config) {
  return {
    name: "wxt:download",
    resolveId(id) {
      if (id.startsWith("url:"))
        return "\0" + id;
    },
    async load(id) {
      if (!id.startsWith("\0url:"))
        return;
      const url = id.replace("\0url:", "");
      return await fetchCached(url, config);
    }
  };
}

// src/core/builders/vite/plugins/multipageMove.ts
var import_node_path4 = require("path");
var import_fs_extra = __toESM(require("fs-extra"), 1);

// src/core/builders/vite/plugins/unimport.ts
var import_unimport = require("unimport");
var import_path = require("path");
var ENABLED_EXTENSIONS = /* @__PURE__ */ new Set([
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".vue",
  ".svelte"
]);
function unimport(config) {
  const options = config.imports;
  if (options === false)
    return [];
  const unimport2 = (0, import_unimport.createUnimport)(options);
  return {
    name: "wxt:unimport",
    async config() {
      await unimport2.scanImportsFromDir(void 0, { cwd: config.srcDir });
    },
    async transform(code, id) {
      if (id.includes("node_modules"))
        return;
      if (!ENABLED_EXTENSIONS.has((0, import_path.extname)(id)))
        return;
      const injected = await unimport2.injectImports(code, id);
      return {
        code: injected.code,
        map: injected.s.generateMap({ hires: "boundary", source: id })
      };
    }
  };
}

// src/core/utils/virtual-modules.ts
var virtualEntrypointTypes = [
  "content-script-main-world",
  "content-script-isolated-world",
  "background",
  "unlisted-script"
];
var virtualEntrypointModuleNames = virtualEntrypointTypes.map(
  (name) => `${name}-entrypoint`
);
var virtualModuleNames = [
  ...virtualEntrypointModuleNames,
  "mock-browser",
  "reload-html"
];

// src/core/builders/vite/plugins/resolveVirtualModules.ts
var import_fs_extra2 = __toESM(require("fs-extra"), 1);

// src/core/builders/vite/plugins/tsconfigPaths.ts
function tsconfigPaths(config) {
  return {
    name: "wxt:aliases",
    async config() {
      return {
        resolve: {
          alias: config.alias
        }
      };
    }
  };
}

// src/core/utils/constants.ts
var VIRTUAL_NOOP_BACKGROUND_MODULE_ID = "virtual:user-background";

// src/core/builders/vite/plugins/bundleAnalysis.ts
var import_rollup_plugin_visualizer = require("@aklinker1/rollup-plugin-visualizer");
var import_node_path5 = __toESM(require("path"), 1);

// src/core/utils/globals.ts
function getGlobals(config) {
  return [
    {
      name: "MANIFEST_VERSION",
      value: config.manifestVersion,
      type: `2 | 3`
    },
    {
      name: "BROWSER",
      value: config.browser,
      type: `string`
    },
    {
      name: "CHROME",
      value: config.browser === "chrome",
      type: `boolean`
    },
    {
      name: "FIREFOX",
      value: config.browser === "firefox",
      type: `boolean`
    },
    {
      name: "SAFARI",
      value: config.browser === "safari",
      type: `boolean`
    },
    {
      name: "EDGE",
      value: config.browser === "edge",
      type: `boolean`
    },
    {
      name: "OPERA",
      value: config.browser === "opera",
      type: `boolean`
    },
    {
      name: "COMMAND",
      value: config.command,
      type: `"build" | "serve"`
    }
  ];
}

// src/core/builders/vite/plugins/globals.ts
function globals(config) {
  return {
    name: "wxt:globals",
    config() {
      const define = {};
      for (const global of getGlobals(config)) {
        define[`import.meta.env.${global.name}`] = JSON.stringify(global.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/webextensionPolyfillMock.ts
var import_node_path6 = __toESM(require("path"), 1);
function webextensionPolyfillMock(config) {
  return {
    name: "wxt:testing-inline-deps",
    config() {
      return {
        resolve: {
          alias: {
            // Alias to use a mocked version of the polyfill
            "webextension-polyfill": import_node_path6.default.resolve(
              config.wxtModuleDir,
              "dist/virtual/mock-browser"
            )
          }
        },
        ssr: {
          // Inline all WXT modules
          noExternal: ["wxt"]
        }
      };
    }
  };
}

// src/core/utils/fs.ts
var import_fs_extra4 = __toESM(require("fs-extra"), 1);
var import_fast_glob = __toESM(require("fast-glob"), 1);

// src/core/wxt.ts
var import_hookable = require("hookable");

// src/core/package-managers/index.ts
var import_nypm = require("nypm");

// src/core/package-managers/npm.ts
var import_node_path7 = __toESM(require("path"), 1);
var import_fs_extra3 = require("fs-extra");

// src/core/utils/fs.ts
async function writeFileIfDifferent(file, newContents) {
  const existingContents = await import_fs_extra4.default.readFile(file, "utf-8").catch(() => void 0);
  if (existingContents !== newContents) {
    await import_fs_extra4.default.writeFile(file, newContents);
  }
}

// src/core/utils/building/build-entrypoints.ts
var import_fs_extra5 = __toESM(require("fs-extra"), 1);
var import_picocolors = __toESM(require("picocolors"), 1);

// src/core/utils/building/find-entrypoints.ts
var import_fs_extra6 = __toESM(require("fs-extra"), 1);
var import_minimatch = require("minimatch");
var import_linkedom2 = require("linkedom");
var import_json5 = __toESM(require("json5"), 1);
var import_fast_glob2 = __toESM(require("fast-glob"), 1);
var import_picocolors2 = __toESM(require("picocolors"), 1);
var PATH_GLOB_TO_TYPE_MAP = {
  "sandbox.html": "sandbox",
  "sandbox/index.html": "sandbox",
  "*.sandbox.html": "sandbox",
  "*.sandbox/index.html": "sandbox",
  "bookmarks.html": "bookmarks",
  "bookmarks/index.html": "bookmarks",
  "history.html": "history",
  "history/index.html": "history",
  "newtab.html": "newtab",
  "newtab/index.html": "newtab",
  "sidepanel.html": "sidepanel",
  "sidepanel/index.html": "sidepanel",
  "*.sidepanel.html": "sidepanel",
  "*.sidepanel/index.html": "sidepanel",
  "devtools.html": "devtools",
  "devtools/index.html": "devtools",
  "background.[jt]s": "background",
  "background/index.[jt]s": "background",
  [VIRTUAL_NOOP_BACKGROUND_MODULE_ID]: "background",
  "content.[jt]s?(x)": "content-script",
  "content/index.[jt]s?(x)": "content-script",
  "*.content.[jt]s?(x)": "content-script",
  "*.content/index.[jt]s?(x)": "content-script",
  [`content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  "popup.html": "popup",
  "popup/index.html": "popup",
  "options.html": "options",
  "options/index.html": "options",
  "*.html": "unlisted-page",
  "*/index.html": "unlisted-page",
  "*.[jt]s?(x)": "unlisted-script",
  "*/index.[jt]s?(x)": "unlisted-script",
  [`*.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style",
  [`*/index.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style"
};

// src/core/utils/building/generate-wxt-dir.ts
var import_unimport2 = require("unimport");
var import_fs_extra7 = __toESM(require("fs-extra"), 1);
var import_node_path8 = __toESM(require("path"), 1);

// src/core/utils/building/resolve-config.ts
var import_c12 = require("c12");
var import_node_path10 = __toESM(require("path"), 1);

// src/core/utils/cache.ts
var import_fs_extra8 = __toESM(require("fs-extra"), 1);
var import_path2 = require("path");
function createFsCache(wxtDir) {
  const getPath = (key) => (0, import_path2.resolve)(wxtDir, "cache", encodeURIComponent(key));
  return {
    async set(key, value) {
      const path8 = getPath(key);
      await (0, import_fs_extra8.ensureDir)((0, import_path2.dirname)(path8));
      await writeFileIfDifferent(path8, value);
    },
    async get(key) {
      const path8 = getPath(key);
      try {
        return await import_fs_extra8.default.readFile(path8, "utf-8");
      } catch {
        return void 0;
      }
    }
  };
}

// src/core/utils/building/resolve-config.ts
var import_consola = __toESM(require("consola"), 1);
var import_defu = __toESM(require("defu"), 1);

// src/core/utils/package.ts
var import_node_path9 = require("path");
var import_fs_extra9 = __toESM(require("fs-extra"), 1);
function isModuleInstalled(name) {
  return import(name).then(() => true).catch(() => false);
}

// src/core/utils/building/resolve-config.ts
var import_fs_extra10 = __toESM(require("fs-extra"), 1);
var import_meta = {};
async function resolveConfig(inlineConfig, command) {
  let userConfig = {};
  let userConfigMetadata;
  if (inlineConfig.configFile !== false) {
    const { config: loadedConfig, ...metadata } = await (0, import_c12.loadConfig)({
      configFile: inlineConfig.configFile,
      name: "wxt",
      cwd: inlineConfig.root ?? process.cwd(),
      rcFile: false,
      jitiOptions: {
        esmResolve: true
      }
    });
    userConfig = loadedConfig ?? {};
    userConfigMetadata = metadata;
  }
  const mergedConfig = await mergeInlineConfig(inlineConfig, userConfig);
  const debug = mergedConfig.debug ?? false;
  const logger = mergedConfig.logger ?? import_consola.default;
  if (debug)
    logger.level = import_consola.LogLevels.debug;
  const browser = mergedConfig.browser ?? "chrome";
  const manifestVersion = mergedConfig.manifestVersion ?? (browser === "firefox" || browser === "safari" ? 2 : 3);
  const mode = mergedConfig.mode ?? COMMAND_MODES[command];
  const env = { browser, command, manifestVersion, mode };
  const root = import_node_path10.default.resolve(
    inlineConfig.root ?? userConfig.root ?? process.cwd()
  );
  const wxtDir = import_node_path10.default.resolve(root, ".wxt");
  const wxtModuleDir = await resolveWxtModuleDir();
  const srcDir = import_node_path10.default.resolve(root, mergedConfig.srcDir ?? root);
  const entrypointsDir = import_node_path10.default.resolve(
    srcDir,
    mergedConfig.entrypointsDir ?? "entrypoints"
  );
  if (await isDirMissing(entrypointsDir)) {
    logMissingDir(logger, "Entrypoints", entrypointsDir);
  }
  const filterEntrypoints = !!mergedConfig.filterEntrypoints?.length ? new Set(mergedConfig.filterEntrypoints) : void 0;
  const publicDir = import_node_path10.default.resolve(srcDir, mergedConfig.publicDir ?? "public");
  if (await isDirMissing(publicDir)) {
    logMissingDir(logger, "Public", publicDir);
  }
  const typesDir = import_node_path10.default.resolve(wxtDir, "types");
  const outBaseDir = import_node_path10.default.resolve(root, mergedConfig.outDir ?? ".output");
  const outDir = import_node_path10.default.resolve(outBaseDir, `${browser}-mv${manifestVersion}`);
  const reloadCommand = mergedConfig.dev?.reloadCommand ?? "Alt+R";
  const runnerConfig = await (0, import_c12.loadConfig)({
    name: "web-ext",
    cwd: root,
    globalRc: true,
    rcFile: ".webextrc",
    overrides: inlineConfig.runner,
    defaults: userConfig.runner
  });
  const alias = Object.fromEntries(
    Object.entries({
      ...mergedConfig.alias,
      "@": srcDir,
      "~": srcDir,
      "@@": root,
      "~~": root
    }).map(([key, value]) => [key, import_node_path10.default.resolve(root, value)])
  );
  let devServerConfig;
  if (command === "serve") {
    let port = mergedConfig.dev?.server?.port;
    if (port == null || !isFinite(port)) {
      const { default: getPort, portNumbers } = await import("get-port");
      port = await getPort({ port: portNumbers(3e3, 3010) });
    }
    devServerConfig = {
      port,
      hostname: "localhost"
    };
  }
  return {
    browser,
    command,
    debug,
    entrypointsDir,
    filterEntrypoints,
    env,
    fsCache: createFsCache(wxtDir),
    imports: await getUnimportOptions(wxtDir, logger, mergedConfig),
    logger,
    manifest: await resolveManifestConfig(env, mergedConfig.manifest),
    manifestVersion,
    mode,
    outBaseDir,
    outDir,
    publicDir,
    wxtModuleDir,
    root,
    runnerConfig,
    srcDir,
    typesDir,
    wxtDir,
    zip: resolveZipConfig(root, mergedConfig),
    transformManifest: mergedConfig.transformManifest,
    analysis: resolveAnalysisConfig(root, mergedConfig),
    userConfigMetadata: userConfigMetadata ?? {},
    alias,
    experimental: (0, import_defu.default)(mergedConfig.experimental, {
      includeBrowserPolyfill: true
    }),
    dev: {
      server: devServerConfig,
      reloadCommand
    },
    hooks: mergedConfig.hooks ?? {},
    vite: mergedConfig.vite ?? (() => ({}))
  };
}
async function resolveManifestConfig(env, manifest) {
  return await (typeof manifest === "function" ? manifest(env) : manifest ?? {});
}
async function mergeInlineConfig(inlineConfig, userConfig) {
  const imports = inlineConfig.imports === false || userConfig.imports === false ? false : userConfig.imports == null && inlineConfig.imports == null ? void 0 : (0, import_defu.default)(inlineConfig.imports ?? {}, userConfig.imports ?? {});
  const manifest = async (env) => {
    const user = await resolveManifestConfig(env, userConfig.manifest);
    const inline = await resolveManifestConfig(env, inlineConfig.manifest);
    return (0, import_defu.default)(inline, user);
  };
  const transformManifest = (manifest2) => {
    userConfig.transformManifest?.(manifest2);
    inlineConfig.transformManifest?.(manifest2);
  };
  const builderConfig = await mergeBuilderConfig(inlineConfig, userConfig);
  return {
    ...(0, import_defu.default)(inlineConfig, userConfig),
    // Custom merge values
    transformManifest,
    imports,
    manifest,
    ...builderConfig
  };
}
function resolveZipConfig(root, mergedConfig) {
  const downloadedPackagesDir = import_node_path10.default.resolve(root, ".wxt/local_modules");
  return {
    name: void 0,
    sourcesTemplate: "{{name}}-{{version}}-sources.zip",
    artifactTemplate: "{{name}}-{{version}}-{{browser}}.zip",
    sourcesRoot: root,
    includeSources: [],
    ...mergedConfig.zip,
    excludeSources: [
      "**/node_modules",
      // WXT files
      "**/web-ext.config.ts",
      // Hidden files
      "**/.*",
      // Tests
      "**/__tests__/**",
      "**/*.+(test|spec).?(c|m)+(j|t)s?(x)",
      // From user
      ...mergedConfig.zip?.excludeSources ?? []
    ],
    downloadPackages: mergedConfig.zip?.downloadPackages ?? [],
    downloadedPackagesDir
  };
}
function resolveAnalysisConfig(root, mergedConfig) {
  const analysisOutputFile = import_node_path10.default.resolve(
    root,
    mergedConfig.analysis?.outputFile ?? "stats.html"
  );
  const analysisOutputDir = import_node_path10.default.dirname(analysisOutputFile);
  const analysisOutputName = import_node_path10.default.parse(analysisOutputFile).name;
  return {
    enabled: mergedConfig.analysis?.enabled ?? false,
    open: mergedConfig.analysis?.open ?? false,
    template: mergedConfig.analysis?.template ?? "treemap",
    outputFile: analysisOutputFile,
    outputDir: analysisOutputDir,
    outputName: analysisOutputName,
    keepArtifacts: mergedConfig.analysis?.keepArtifacts ?? false
  };
}
async function getUnimportOptions(wxtDir, logger, config) {
  if (config.imports === false)
    return false;
  const enabledConfig = config.imports?.eslintrc?.enabled;
  let enabled;
  switch (enabledConfig) {
    case void 0:
    case "auto":
      enabled = await isModuleInstalled("eslint");
      break;
    default:
      enabled = enabledConfig;
  }
  const defaultOptions = {
    debugLog: logger.debug,
    imports: [
      { name: "defineConfig", from: "wxt" },
      { name: "fakeBrowser", from: "wxt/testing" }
    ],
    presets: [
      { package: "wxt/client" },
      { package: "wxt/browser" },
      { package: "wxt/sandbox" },
      { package: "wxt/storage" }
    ],
    warn: logger.warn,
    dirs: ["components", "composables", "hooks", "utils"],
    eslintrc: {
      enabled,
      filePath: import_node_path10.default.resolve(wxtDir, "eslintrc-auto-import.json"),
      globalsPropValue: true
    }
  };
  return (0, import_defu.default)(
    config.imports ?? {},
    defaultOptions
  );
}
async function resolveWxtModuleDir() {
  const requireResolve = require?.resolve ?? (await import("module")).default.createRequire(import_meta.url).resolve;
  return import_node_path10.default.resolve(requireResolve("wxt"), "../..");
}
async function isDirMissing(dir) {
  return !await import_fs_extra10.default.exists(dir);
}
function logMissingDir(logger, name, expected) {
  logger.warn(
    `${name} directory not found: ./${normalizePath(
      import_node_path10.default.relative(process.cwd(), expected)
    )}`
  );
}
var COMMAND_MODES = {
  build: "production",
  serve: "development"
};
async function mergeBuilderConfig(inlineConfig, userConfig) {
  const vite = await import("vite").catch(() => void 0);
  if (vite) {
    return {
      vite: async (env) => {
        const resolvedInlineConfig = await inlineConfig.vite?.(env) ?? {};
        const resolvedUserConfig = await userConfig.vite?.(env) ?? {};
        return vite.mergeConfig(resolvedUserConfig, resolvedInlineConfig);
      }
    };
  }
  throw Error("Builder not found. Make sure vite is installed.");
}

// src/core/utils/building/import-entrypoint.ts
var import_jiti = __toESM(require("jiti"), 1);
var import_unimport3 = require("unimport");
var import_fs_extra11 = __toESM(require("fs-extra"), 1);
var import_node_path11 = require("path");
var import_esbuild = require("esbuild");
var import_node_url = require("url");

// src/core/utils/building/internal-build.ts
var import_picocolors5 = __toESM(require("picocolors"), 1);
var import_fs_extra14 = __toESM(require("fs-extra"), 1);

// src/core/utils/log/printFileList.ts
var import_node_path12 = __toESM(require("path"), 1);
var import_picocolors3 = __toESM(require("picocolors"), 1);
var import_fs_extra12 = __toESM(require("fs-extra"), 1);
var import_filesize = require("filesize");
var DEFAULT_COLOR = import_picocolors3.default.blue;
var CHUNK_COLORS = {
  ".js.map": import_picocolors3.default.gray,
  ".cjs.map": import_picocolors3.default.gray,
  ".mjs.map": import_picocolors3.default.gray,
  ".html": import_picocolors3.default.green,
  ".css": import_picocolors3.default.magenta,
  ".js": import_picocolors3.default.cyan,
  ".cjs": import_picocolors3.default.cyan,
  ".mjs": import_picocolors3.default.cyan,
  ".zip": import_picocolors3.default.yellow
};

// src/core/utils/log/printHeader.ts
var import_picocolors4 = __toESM(require("picocolors"), 1);
var import_consola2 = require("consola");

// src/core/utils/building/internal-build.ts
var import_fast_glob3 = __toESM(require("fast-glob"), 1);

// src/core/utils/manifest.ts
var import_fs_extra13 = __toESM(require("fs-extra"), 1);
var import_defu2 = __toESM(require("defu"), 1);

// src/core/utils/building/internal-build.ts
var import_node_path13 = require("path");
var import_consola3 = __toESM(require("consola"), 1);
var import_rollup_plugin_visualizer2 = require("@aklinker1/rollup-plugin-visualizer");
var import_ci_info = require("ci-info");

// src/testing/wxt-vitest-plugin.ts
function WxtVitest(inlineConfig) {
  return resolveConfig(inlineConfig ?? {}, "serve").then((config) => [
    webextensionPolyfillMock(config),
    unimport(config),
    globals(config),
    download(config),
    tsconfigPaths(config)
  ]);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  WxtVitest,
  fakeBrowser
});
